<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vampire Survivor Klonu (Canvas)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            user-select: none;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated; /* Piksellerin net gÃ¶rÃ¼nmesi iÃ§in */
        }

        /* ARAYÃœZ (HUD) */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-text {
            position: absolute;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        #xp-bar-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 20px;
            background: #333;
        }
        #xp-bar-fill {
            height: 100%;
            background: #4caf50;
            width: 0%;
            transition: width 0.2s;
        }

        #timer { top: 30px; left: 50%; transform: translateX(-50%); font-size: 24px; }
        #kill-count { padding-left: 20px; font-size: 20px; color: #ff6b6b; }
        #level-display { padding-top: 20px; padding-left: 20px; font-size: 20px; color: #4caf50; }
        #hp-display { bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 20px; color: #ff4757; }

        /* MENÃœLER (Modal) */
        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify_content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }
        .hidden { display: none !important; }

        h1 { font-size: 48px; color: #ff4757; text-shadow: 3px 3px 0 #000; margin-bottom: 20px; text-align: center;}
        p { font-size: 18px; color: #ccc; max-width: 600px; text-align: center; margin-bottom: 30px; padding: 0 20px;}

        button {
            background: #333;
            color: white;
            border: 2px solid #666;
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            font-family: inherit;
            margin: 10px;
            transition: 0.2s;
        }
        button:hover { background: #555; border-color: #fff; }

        /* YÃœKSELTME KARTLARI */
        #upgrade-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .upgrade-card {
            background: #2f3542;
            border: 2px solid #747d8c;
            padding: 20px;
            width: 200px;
            cursor: pointer;
            text-align: center;
        }
        .upgrade-card:hover { transform: translateY(-5px); border-color: #ffa502; }
        .upgrade-title { color: #ffa502; font-size: 18px; margin-bottom: 10px; font-weight: bold;}
        .upgrade-desc { font-size: 12px; color: #dfe4ea; }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="xp-bar-container"><div id="xp-bar-fill"></div></div>
        <div id="timer">00:00</div>
        <div id="level-display">LVL 1</div>
        <div id="kill-count">ðŸ’€ 0</div>
        <div id="hp-display">HP: 100/100</div>
    </div>

    <div id="start-screen" class="modal">
        <h1>SURVIVOR KLONU</h1>
        <p>Bilgisayar: WASD / Ok TuÅŸlarÄ±<br>Mobil: Ekrana dokun ve sÃ¼rÃ¼kle (Joystick)<br><br>Maviler XP, KÄ±rmÄ±zÄ±lar DÃ¼ÅŸman.</p>
        <button onclick="startGame()">OYUNA BAÅžLA</button>
    </div>

    <div id="levelup-screen" class="modal hidden">
        <h1 style="color: #ffa502">SEVÄ°YE ATLADIN!</h1>
        <div id="upgrade-options"></div>
    </div>

    <div id="gameover-screen" class="modal hidden">
        <h1>Ã–LDÃœN</h1>
        <p id="final-stats"></p>
        <button onclick="location.reload()">TEKRAR DENE</button>
    </div>

<script>
/**
 * --- AYARLAR VE SABÄ°TLER ---
 */
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');

CANVAS.width = window.innerWidth;
CANVAS.height = window.innerHeight;

const GAME_CONFIG = {
    playerSpeed: 4,
    baseEnemySpeed: 1.5,
    enemySpawnRate: 60,
    pickupRadius: 50,
    maxEnemies: 300
};

// --- SPRITE YÃœKLEME ---
// NOT: Bu URL'leri kendi yÃ¼klediÄŸin gÃ¶rsellerin yollarÄ± ile deÄŸiÅŸtir.
const playerSprite = new Image();
playerSprite.src = "walkLeftLow.webp"; // Oyuncu Sprite Sheet URL

const enemySprite = new Image();
enemySprite.src = "orgWalkLeft.webp"; // DÃ¼ÅŸman Sprite Sheet URL (BOÅž BIRAKTIM, KENDÄ°N EKLE)

/**
 * --- OYUN DURUMU (STATE) ---
 */
let gameState = {
    running: false,
    paused: false,
    frames: 0,
    time: 0,
    enemiesKilled: 0
};

let camera = { x: 0, y: 0 };

/**
 * --- JOYSTICK SÄ°STEMÄ° ---
 */
const joystick = {
    active: false,
    originX: 0,
    originY: 0,
    currentX: 0,
    currentY: 0,
    dx: 0,
    dy: 0,
    maxRadius: 50
};

CANVAS.addEventListener('touchstart', e => {
    if (!gameState.running || gameState.paused) return;
    e.preventDefault();
    const touch = e.touches[0];
    joystick.active = true;
    joystick.originX = touch.clientX;
    joystick.originY = touch.clientY;
    joystick.currentX = touch.clientX;
    joystick.currentY = touch.clientY;
    joystick.dx = 0;
    joystick.dy = 0;
}, {passive: false});

CANVAS.addEventListener('touchmove', e => {
    if (!joystick.active) return;
    e.preventDefault();
    const touch = e.touches[0];
    
    let deltaX = touch.clientX - joystick.originX;
    let deltaY = touch.clientY - joystick.originY;
    let distance = Math.sqrt(deltaX*deltaX + deltaY*deltaY);

    if (distance > joystick.maxRadius) {
        const angle = Math.atan2(deltaY, deltaX);
        deltaX = Math.cos(angle) * joystick.maxRadius;
        deltaY = Math.sin(angle) * joystick.maxRadius;
        distance = joystick.maxRadius;
    }

    joystick.currentX = joystick.originX + deltaX;
    joystick.currentY = joystick.originY + deltaY;

    if (distance > 0) {
        joystick.dx = deltaX / joystick.maxRadius;
        joystick.dy = deltaY / joystick.maxRadius;
    } else {
        joystick.dx = 0;
        joystick.dy = 0;
    }
}, {passive: false});

CANVAS.addEventListener('touchend', e => {
    e.preventDefault();
    joystick.active = false;
    joystick.dx = 0;
    joystick.dy = 0;
});

/**
 * --- SINIFLAR ---
 */

class Player {
    constructor() {
        this.x = 0;
        this.y = 0;
        // Hitbox boyutu (Ã‡arpÄ±ÅŸma iÃ§in)
        this.width = 30; 
        this.height = 30;
        
        this.color = '#3498db';
        this.hp = 100;
        this.maxHp = 100;
        this.level = 1;
        this.xp = 0;
        this.xpToNextLevel = 50; 
        this.weapons = [];
        this.modifiers = {
            area: 1,
            speed: 1,
            power: 1,
            moveSpeed: 1
        };

        // --- SPRITE ANIMASYON AYARLARI ---
        // GÃ¶rsel: 751x169, 8 Frame
        this.spriteWidth = 751; 
        this.spriteHeight = 169;
        this.totalFrames = 8;
        this.frameWidth = this.spriteWidth / this.totalFrames; 
        this.frameHeight = this.spriteHeight;
        
        this.currentFrame = 0;
        this.gameFrame = 0;
        this.staggerFrames = 5; 
        
        this.facingRight = true; 
        this.isMoving = false;

        this.addWeapon('magic_wand');
    }

    update() {
        let dx = 0;
        let dy = 0;

        // Klavye KontrolÃ¼
        if (keys['w'] || keys['ArrowUp']) dy = -1;
        if (keys['s'] || keys['ArrowDown']) dy = 1;
        if (keys['a'] || keys['ArrowLeft']) dx = -1;
        if (keys['d'] || keys['ArrowRight']) dx = 1;

        if (dx !== 0 || dy !== 0) {
            const length = Math.sqrt(dx*dx + dy*dy);
            dx /= length;
            dy /= length;
        }

        // Joystick KontrolÃ¼
        if (joystick.active) {
            dx = joystick.dx;
            dy = joystick.dy;
        }

        // Hareketi uygula ve Animasyon Durumunu GÃ¼ncelle
        if (dx !== 0 || dy !== 0) {
            this.x += dx * GAME_CONFIG.playerSpeed * this.modifiers.moveSpeed;
            this.y += dy * GAME_CONFIG.playerSpeed * this.modifiers.moveSpeed;
            this.isMoving = true;
            
            // YÃ¶nÃ¼ belirle (SaÄŸ mÄ± Sol mu?)
            if (dx > 0) this.facingRight = true;
            if (dx < 0) this.facingRight = false;

        } else {
            this.isMoving = false;
        }

        // Animasyon Frame HesabÄ±
        if (this.isMoving) {
            this.gameFrame++;
            if (this.gameFrame % this.staggerFrames === 0) {
                this.currentFrame = (this.currentFrame + 1) % this.totalFrames;
            }
        } else {
            this.currentFrame = 0; 
        }

        // SilahlarÄ± gÃ¼ncelle
        this.weapons.forEach(w => w.update(this));
    }

    draw() {
        const screenX = CANVAS.width / 2;
        const screenY = CANVAS.height / 2;
        
        // --- SPRITE Ã‡Ä°ZÄ°MÄ° ---
        if (playerSprite.complete && playerSprite.naturalWidth !== 0) {
            CTX.save(); 
            
            const displayH = 80;
            const displayW = displayH * (this.frameWidth / this.frameHeight);

            CTX.translate(screenX, screenY);

            if (this.facingRight) {
                CTX.scale(-1, 1);
            }

            CTX.drawImage(
                playerSprite,
                this.currentFrame * this.frameWidth, 
                0, 
                this.frameWidth, 
                this.frameHeight, 
                -displayW / 2, 
                -displayH / 2, 
                displayW, 
                displayH  
            );

            CTX.restore();
        } else {
            // FALLBACK
            CTX.fillStyle = this.color;
            CTX.fillRect(screenX - this.width/2, screenY - this.height/2, this.width, this.height);
            CTX.strokeStyle = 'white';
            CTX.lineWidth = 2;
            CTX.strokeRect(screenX - this.width/2, screenY - this.height/2, this.width, this.height);
        }

        // --- GÃ–RSEL CAN BARI ---
        const barWidth = 40;
        const barHeight = 5;
        const barOffset = (playerSprite.complete && playerSprite.naturalWidth !== 0) ? 50 : 20;
        const barX = screenX - barWidth / 2;
        const barY = screenY - barOffset;

        CTX.fillStyle = '#e74c3c'; 
        CTX.fillRect(barX, barY, barWidth, barHeight);

        const hpPercent = Math.max(0, this.hp / this.maxHp);
        CTX.fillStyle = '#2ecc71';
        CTX.fillRect(barX, barY, barWidth * hpPercent, barHeight);
        
        CTX.strokeStyle = '#000';
        CTX.lineWidth = 1;
        CTX.strokeRect(barX, barY, barWidth, barHeight);
    }
    
    drawWeapons() {
        this.weapons.forEach(w => w.draw(this));
    }

    takeDamage(amount) {
        this.hp -= amount;
        updateHUD();
        if (this.hp <= 0) gameOver();
    }

    gainXp(amount) {
        this.xp += amount;
        if (this.xp >= this.xpToNextLevel) {
            this.levelUp();
        }
        updateHUD();
    }

    levelUp() {
        this.level++;
        this.xp -= this.xpToNextLevel;
        this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5);
        
        joystick.active = false;
        joystick.dx = 0;
        joystick.dy = 0;

        gameState.paused = true;
        showUpgradeMenu();
    }

    addWeapon(type) {
        const existing = this.weapons.find(w => w.type === type);
        if (existing) {
            existing.levelUp();
        } else {
            if (type === 'magic_wand') this.weapons.push(new MagicWand());
            if (type === 'garlic') this.weapons.push(new Garlic());
            if (type === 'axe') this.weapons.push(new Axe());
        }
    }
}

class Enemy {
    constructor() {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.max(CANVAS.width, CANVAS.height) / 2 + 100;
        
        this.x = player.x + Math.cos(angle) * radius;
        this.y = player.y + Math.sin(angle) * radius;
        
        this.width = 25; // Hitbox
        this.height = 25;
        this.color = '#e74c3c';
        
        this.hp = 25 + (player.level * 5); 
        this.speed = GAME_CONFIG.baseEnemySpeed + (Math.random() * 0.5);
        this.damage = 10 + (player.level * 0.5);

        // --- DÃœÅžMAN SPRITE AYARLARI ---
        // LÃ¼tfen bu deÄŸerleri kendi sprite sheet'ine gÃ¶re gÃ¼ncelle:
        this.spriteWidth = 751; 
        this.spriteHeight = 169;
        this.totalFrames = 8;
        this.frameWidth = this.spriteWidth / this.totalFrames;
        this.frameHeight = this.spriteHeight;

        // "Robot Ordusu" etkisini kÄ±rmak iÃ§in rastgele baÅŸlangÄ±Ã§:
        this.currentFrame = Math.floor(Math.random() * this.totalFrames);
        this.gameFrame = Math.floor(Math.random() * 10);
        this.staggerFrames = 8; // DÃ¼ÅŸmanlar biraz daha yavaÅŸ veya farklÄ± hÄ±zda animate olabilir

        this.facingRight = true;
    }

    update() {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist > 0) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
            
            // YÃ¶n belirleme
            if (dx > 0) this.facingRight = true;
            else this.facingRight = false;

            // Animasyon Ä°lerlemesi
            this.gameFrame++;
            if (this.gameFrame % this.staggerFrames === 0) {
                this.currentFrame = (this.currentFrame + 1) % this.totalFrames;
            }
        }

        if (dist < 30) {
            player.takeDamage(this.damage * 0.05);
        }
    }

    draw() {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;

        // Culling (Ekran dÄ±ÅŸÄ± Ã§izim engelleme)
        if (screenX < -50 || screenX > CANVAS.width + 50 || 
            screenY < -50 || screenY > CANVAS.height + 50) return;

        // --- SPRITE Ã‡Ä°ZÄ°MÄ° ---
        if (enemySprite.complete && enemySprite.naturalWidth !== 0) {
            CTX.save();

            const displayH = 100; // DÃ¼ÅŸman boyutu (GÃ¶rsel olarak)
            const displayW = displayH * (this.frameWidth / this.frameHeight);

            CTX.translate(screenX, screenY);

            if (this.facingRight) {
                CTX.scale(-1, 1);
            }

            CTX.drawImage(
                enemySprite,
                this.currentFrame * this.frameWidth,
                0,
                this.frameWidth,
                this.frameHeight,
                -displayW / 2,
                -displayH / 2,
                displayW,
                displayH
            );

            CTX.restore();
        } else {
            // FALLBACK (GÃ¶rsel yoksa KÄ±rmÄ±zÄ± Kare)
            CTX.fillStyle = this.color;
            CTX.fillRect(screenX - this.width/2, screenY - this.height/2, this.width, this.height);
        }
    }
}

class Gem {
    constructor(x, y, value) {
        this.x = x;
        this.y = y;
        this.value = value;
        this.radius = 6;
        this.color = value > 10 ? '#34e7e4' : '#2ecc71';
    }

    update() {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < GAME_CONFIG.pickupRadius * 2) {
            this.x += (dx / dist) * 8;
            this.y += (dy / dist) * 8;
        }

        if (dist < 20) {
            player.gainXp(this.value);
            return true;
        }
        return false;
    }

    draw() {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        
        if (screenX < -20 || screenX > CANVAS.width + 20 || 
            screenY < -20 || screenY > CANVAS.height + 20) return;

        CTX.beginPath();
        CTX.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
        CTX.fillStyle = this.color;
        CTX.fill();
        CTX.strokeStyle = '#000';
        CTX.stroke();
    }
}

class DamageText {
    constructor(x, y, amount) {
        this.x = x;
        this.y = y;
        this.amount = Math.floor(amount);
        this.life = 30;
        this.vy = -2;
    }

    update() {
        this.y += this.vy;
        this.life--;
        return this.life <= 0;
    }

    draw() {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        
        CTX.fillStyle = `rgba(255, 255, 255, ${this.life / 30})`;
        CTX.font = 'bold 16px Arial';
        CTX.fillText(this.amount, screenX, screenY);
    }
}

/**
 * --- SÄ°LAH SÄ°STEMÄ° ---
 */

class Weapon {
    constructor(name, cooldown) {
        this.name = name;
        this.baseCooldown = cooldown;
        this.timer = 0;
        this.level = 1;
        this.damage = 10;
        this.type = '';
    }

    update(player) {
        if (this.timer > 0) {
            this.timer--;
        } else {
            this.fire(player);
            this.timer = this.baseCooldown / player.modifiers.speed;
        }
    }
    
    draw(player) { /* Override */ }

    levelUp() {
        this.level++;
        this.damage += 5;
        this.baseCooldown *= 0.9;
    }
    
    fire(player) { /* Override */ }
}

class MagicWand extends Weapon {
    constructor() {
        super('Asa', 60);
        this.type = 'magic_wand';
        this.damage = 15;
    }

    fire(player) {
        let closest = null;
        let minDist = Infinity;

        enemies.forEach(e => {
            const dx = e.x - player.x;
            const dy = e.y - player.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d < minDist) {
                minDist = d;
                closest = e;
            }
        });

        if (closest && minDist < 400) {
            projectiles.push(new Projectile(player.x, player.y, closest, this.damage));
        }
    }
}

class Garlic extends Weapon {
    constructor() {
        super('SarÄ±msak', 10);
        this.type = 'garlic';
        this.radius = 80;
        this.damage = 2;
    }

    fire(player) {
        enemies.forEach(e => {
            const dx = e.x - player.x;
            const dy = e.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < (this.radius * player.modifiers.area)) {
                e.hp -= (this.damage * player.modifiers.power);
                e.x += (dx/dist) * 5;
                e.y += (dy/dist) * 5;
                
                if (gameState.frames % 10 === 0) {
                    texts.push(new DamageText(e.x, e.y, this.damage));
                }
                
                checkEnemyDeath(e);
            }
        });
    }

    draw(player) {
        const screenX = player.x - camera.x;
        const screenY = player.y - camera.y;

        CTX.beginPath();
        CTX.arc(screenX, screenY, this.radius * player.modifiers.area, 0, Math.PI*2);
        CTX.fillStyle = `rgba(255, 200, 200, ${0.1 + (Math.sin(gameState.frames * 0.1) * 0.05)})`;
        CTX.fill();
        CTX.strokeStyle = 'rgba(255, 100, 100, 0.3)';
        CTX.stroke();
    }
}

class Axe extends Weapon {
    constructor() {
        super('Balta', 90);
        this.type = 'axe';
        this.damage = 25;
    }
    
    fire(player) {
        let vx = (Math.random() - 0.5) * 4;
        let vy = -8;
        projectiles.push(new AxeProjectile(player.x, player.y, vx, vy, this.damage));
    }
}

class Projectile {
    constructor(x, y, target, damage) {
        this.x = x;
        this.y = y;
        this.damage = damage;
        this.speed = 7;
        this.radius = 5;
        this.markedForDeletion = false;

        const dx = target.x - x;
        const dy = target.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        this.vx = (dx / dist) * this.speed;
        this.vy = (dy / dist) * this.speed;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;

        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        if (screenX < -50 || screenX > CANVAS.width+50 || screenY < -50 || screenY > CANVAS.height+50) {
            this.markedForDeletion = true;
        }

        for (let e of enemies) {
            const dx = e.x - this.x;
            const dy = e.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < e.width) {
                e.hp -= this.damage;
                texts.push(new DamageText(e.x, e.y, this.damage));
                checkEnemyDeath(e);
                this.markedForDeletion = true;
                break;
            }
        }
    }

    draw() {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        CTX.fillStyle = '#f1c40f';
        CTX.beginPath();
        CTX.arc(screenX, screenY, this.radius, 0, Math.PI*2);
        CTX.fill();
    }
}

class AxeProjectile {
    constructor(x, y, vx, vy, damage) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.damage = damage;
        this.gravity = 0.3;
        this.markedForDeletion = false;
        this.width = 15;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;

        if (this.y > player.y + 400) this.markedForDeletion = true;

        for (let e of enemies) {
            const dx = e.x - this.x;
            const dy = e.y - this.y;
            if (Math.abs(dx) < 20 && Math.abs(dy) < 20) {
                e.hp -= this.damage;
                texts.push(new DamageText(e.x, e.y, this.damage));
                checkEnemyDeath(e);
            }
        }
    }

    draw() {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        CTX.fillStyle = '#95a5a6';
        CTX.fillRect(screenX, screenY, this.width, this.width);
    }
}

/**
 * --- OYUN DÃ–NGÃœSÃœ DEÄžÄ°ÅžKENLERÄ° ---
 */
let player;
let enemies = [];
let gems = [];
let projectiles = [];
let texts = [];
let keys = {};

window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

function initGame() {
    player = new Player();
    enemies = [];
    gems = [];
    projectiles = [];
    texts = [];
    gameState = {
        running: true,
        paused: false,
        frames: 0,
        time: 0,
        enemiesKilled: 0
    };
    updateHUD();
    gameLoop();
}

function spawnEnemy() {
    const spawnRate = Math.max(10, GAME_CONFIG.enemySpawnRate - Math.floor(gameState.time / 10));
    
    if (gameState.frames % spawnRate === 0) {
        if (enemies.length < GAME_CONFIG.maxEnemies) {
            enemies.push(new Enemy());
        }
    }
}

function checkEnemyDeath(enemy) {
    if (enemy.hp <= 0) {
        gems.push(new Gem(enemy.x, enemy.y, 10 + Math.random() * 5));
        gameState.enemiesKilled++;
    }
}

function update() {
    if (!gameState.running || gameState.paused) return;

    gameState.frames++;
    if (gameState.frames % 60 === 0) {
        gameState.time++;
        document.getElementById('timer').innerText = new Date(gameState.time * 1000).toISOString().substr(14, 5);
    }

    player.update();
    
    camera.x = player.x - CANVAS.width / 2;
    camera.y = player.y - CANVAS.height / 2;

    spawnEnemy();

    enemies = enemies.filter(e => e.hp > 0);
    enemies.forEach(e => e.update());

    projectiles.forEach(p => p.update());
    projectiles = projectiles.filter(p => !p.markedForDeletion);

    gems = gems.filter(g => !g.update());

    texts = texts.filter(t => !t.update());
}

function draw() {
    CTX.fillStyle = '#222';
    CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

    const gridSize = 100;
    const offsetX = -camera.x % gridSize;
    const offsetY = -camera.y % gridSize;
    
    CTX.strokeStyle = '#333';
    CTX.lineWidth = 1;
    CTX.beginPath();
    for (let x = offsetX; x < CANVAS.width; x += gridSize) {
        CTX.moveTo(x, 0);
        CTX.lineTo(x, CANVAS.height);
    }
    for (let y = offsetY; y < CANVAS.height; y += gridSize) {
        CTX.moveTo(0, y);
        CTX.lineTo(CANVAS.width, y);
    }
    CTX.stroke();

    gems.forEach(g => g.draw());
    
    if(player) player.drawWeapons();

    enemies.forEach(e => e.draw());
    projectiles.forEach(p => p.draw());
    
    if(player) player.draw();
    
    texts.forEach(t => t.draw());

    if (joystick.active) {
        CTX.beginPath();
        CTX.arc(joystick.originX, joystick.originY, joystick.maxRadius, 0, Math.PI * 2);
        CTX.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        CTX.lineWidth = 2;
        CTX.stroke();

        CTX.beginPath();
        CTX.arc(joystick.currentX, joystick.currentY, 20, 0, Math.PI * 2);
        CTX.fillStyle = 'rgba(255, 255, 255, 0.5)';
        CTX.fill();
    }
}

function gameLoop() {
    if (gameState.running) {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }
}

/**
 * --- UI FONKSÄ°YONLARI ---
 */
function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    initGame();
}

function gameOver() {
    gameState.running = false;
    document.getElementById('gameover-screen').classList.remove('hidden');
    document.getElementById('final-stats').innerText = 
        `SÃ¼re: ${document.getElementById('timer').innerText} | Ã–ldÃ¼rÃ¼len: ${gameState.enemiesKilled} | Seviye: ${player.level}`;
}

function updateHUD() {
    document.getElementById('kill-count').innerText = 'ðŸ’€ ' + gameState.enemiesKilled;
    document.getElementById('level-display').innerText = 'LVL ' + player.level;
    document.getElementById('hp-display').innerText = `HP: ${Math.floor(player.hp)}/${player.maxHp}`;
    
    const xpPercent = (player.xp / player.xpToNextLevel) * 100;
    document.getElementById('xp-bar-fill').style.width = xpPercent + '%';
}

function showUpgradeMenu() {
    const container = document.getElementById('upgrade-options');
    container.innerHTML = '';
    
    const options = [
        { id: 'magic_wand', title: 'BÃ¼yÃ¼ AsasÄ±', desc: 'En yakÄ±n dÃ¼ÅŸmana atÄ±ÅŸ yapar.' },
        { id: 'garlic', title: 'SarÄ±msak', desc: 'EtrafÄ±nda hasar alanÄ± oluÅŸturur.' },
        { id: 'axe', title: 'Balta', desc: 'YukarÄ± doÄŸru aÄŸÄ±r hasarlÄ± balta atar.' },
        { id: 'heal', title: 'Tavuk Budu', desc: '%30 Can Yeniler.' },
        { id: 'speed', title: 'HÄ±z Ä°ksiri', desc: 'Hareket hÄ±zÄ±nÄ± artÄ±rÄ±r.' }
    ];

    const choices = options.sort(() => 0.5 - Math.random()).slice(0, 3);

    choices.forEach(opt => {
        const div = document.createElement('div');
        div.className = 'upgrade-card';
        div.innerHTML = `<div class="upgrade-title">${opt.title}</div><div class="upgrade-desc">${opt.desc}</div>`;
        div.onclick = () => selectUpgrade(opt.id);
        container.appendChild(div);
    });

    document.getElementById('levelup-screen').classList.remove('hidden');
}

function selectUpgrade(id) {
    if (id === 'heal') {
        player.hp = Math.min(player.hp + 30, player.maxHp);
    } else if (id === 'speed') {
        player.modifiers.moveSpeed += 0.1;
    } else {
        player.addWeapon(id);
    }
    
    document.getElementById('levelup-screen').classList.add('hidden');
    gameState.paused = false;
    joystick.active = false; 
    updateHUD();
}

window.addEventListener('resize', () => {
    CANVAS.width = window.innerWidth;
    CANVAS.height = window.innerHeight;
});

</script>
</body>
</html>