<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vampire Survivor Klonu (Canvas)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            user-select: none;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated; /* Piksellerin net g√∂r√ºnmesi i√ßin */
        }

        /* ARAY√úZ (HUD) */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-text {
            position: absolute;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        #xp-bar-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 20px;
            background: #333;
        }
        #xp-bar-fill {
            height: 100%;
            background: #4caf50;
            width: 0%;
            transition: width 0.2s;
        }

        #timer { top: 30px; left: 50%; transform: translateX(-50%); font-size: 24px; }
        #kill-count { padding-left: 20px; font-size: 20px; color: #ff6b6b; }
        #level-display { padding-top: 20px; padding-left: 20px; font-size: 20px; color: #4caf50; }
        #hp-display { bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 20px; color: #ff4757; }

        /* MEN√úLER (Modal) */
        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify_content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }
        .hidden { display: none !important; }

        h1 { font-size: 48px; color: #ff4757; text-shadow: 3px 3px 0 #000; margin-bottom: 20px; text-align: center;}
        p { font-size: 18px; color: #ccc; max-width: 600px; text-align: center; margin-bottom: 30px; padding: 0 20px;}

        button {
            background: #333;
            color: white;
            border: 2px solid #666;
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            font-family: inherit;
            margin: 10px;
            transition: 0.2s;
        }
        button:hover { background: #555; border-color: #fff; }

        /* Y√úKSELTME KARTLARI */
        #upgrade-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .upgrade-card {
            background: #2f3542;
            border: 2px solid #747d8c;
            padding: 20px;
            width: 200px;
            cursor: pointer;
            text-align: center;
        }
        .upgrade-card:hover { transform: translateY(-5px); border-color: #ffa502; }
        .upgrade-title { color: #ffa502; font-size: 18px; margin-bottom: 10px; font-weight: bold;}
        .upgrade-desc { font-size: 12px; color: #dfe4ea; }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="xp-bar-container"><div id="xp-bar-fill"></div></div>
        <div id="timer">00:00</div>
        <div id="level-display">LVL 1</div>
        <div id="kill-count">üíÄ 0</div>
        <div id="hp-display">HP: 100/100</div>
    </div>

    <div id="start-screen" class="modal">
        <h1>SURVIVOR KLONU</h1>
        <p>Bilgisayar: WASD / Ok Tu≈ülarƒ±<br>Mobil: Ekrana dokun ve s√ºr√ºkle (Joystick)<br><br>Maviler XP, Kƒ±rmƒ±zƒ±lar D√º≈üman.</p>
        <button onclick="startGame()">OYUNA BA≈ûLA</button>
    </div>

    <div id="levelup-screen" class="modal hidden">
        <h1 style="color: #ffa502">SEVƒ∞YE ATLADIN!</h1>
        <div id="upgrade-options"></div>
    </div>

    <div id="gameover-screen" class="modal hidden">
        <h1>√ñLD√úN</h1>
        <p id="final-stats"></p>
        <button onclick="location.reload()">TEKRAR DENE</button>
    </div>

<script>
/**
 * --- AYARLAR VE SABƒ∞TLER ---
 */
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');

CANVAS.width = window.innerWidth;
CANVAS.height = window.innerHeight;

const GAME_CONFIG = {
    playerSpeed: 4,
    baseEnemySpeed: 1.5,
    enemySpawnRate: 60,
    pickupRadius: 50,
    maxEnemies: 300
};

// --- SPRITE Y√úKLEME ---
const playerSprite = new Image();
playerSprite.src = "walkLeftLow.webp"; // Oyuncu Sprite Sheet URL

// NOT: D√º≈üman sprite'larƒ± artƒ±k Enemy sƒ±nƒ±fƒ±nƒ±n i√ßinde y√∂netiliyor.

/**
 * --- OYUN DURUMU (STATE) ---
 */
let gameState = {
    running: false,
    paused: false,
    frames: 0,
    time: 0,
    enemiesKilled: 0
};

let camera = { x: 0, y: 0 };

/**
 * --- JOYSTICK Sƒ∞STEMƒ∞ ---
 */
const joystick = {
    active: false,
    originX: 0,
    originY: 0,
    currentX: 0,
    currentY: 0,
    dx: 0,
    dy: 0,
    maxRadius: 50
};

CANVAS.addEventListener('touchstart', e => {
    if (!gameState.running || gameState.paused) return;
    e.preventDefault();
    const touch = e.touches[0];
    joystick.active = true;
    joystick.originX = touch.clientX;
    joystick.originY = touch.clientY;
    joystick.currentX = touch.clientX;
    joystick.currentY = touch.clientY;
    joystick.dx = 0;
    joystick.dy = 0;
}, {passive: false});

CANVAS.addEventListener('touchmove', e => {
    if (!joystick.active) return;
    e.preventDefault();
    const touch = e.touches[0];
    
    let deltaX = touch.clientX - joystick.originX;
    let deltaY = touch.clientY - joystick.originY;
    let distance = Math.sqrt(deltaX*deltaX + deltaY*deltaY);

    if (distance > joystick.maxRadius) {
        const angle = Math.atan2(deltaY, deltaX);
        deltaX = Math.cos(angle) * joystick.maxRadius;
        deltaY = Math.sin(angle) * joystick.maxRadius;
        distance = joystick.maxRadius;
    }

    joystick.currentX = joystick.originX + deltaX;
    joystick.currentY = joystick.originY + deltaY;

    if (distance > 0) {
        joystick.dx = deltaX / joystick.maxRadius;
        joystick.dy = deltaY / joystick.maxRadius;
    } else {
        joystick.dx = 0;
        joystick.dy = 0;
    }
}, {passive: false});

CANVAS.addEventListener('touchend', e => {
    e.preventDefault();
    joystick.active = false;
    joystick.dx = 0;
    joystick.dy = 0;
});

/**
 * --- SINIFLAR ---
 */

class Player {
    constructor() {
        this.x = 0;
        this.y = 0;
        this.width = 30; 
        this.height = 30;
        
        this.color = '#3498db';
        this.hp = 100;
        this.maxHp = 100;
        this.level = 1;
        this.xp = 0;
        this.xpToNextLevel = 50; 
        this.weapons = [];
        this.modifiers = {
            area: 1,
            speed: 1,
            power: 1,
            moveSpeed: 1
        };

        // Player Sprite Config
        this.spriteWidth = 751; 
        this.spriteHeight = 169;
        this.totalFrames = 8;
        this.frameWidth = this.spriteWidth / this.totalFrames; 
        this.frameHeight = this.spriteHeight;
        
        this.currentFrame = 0;
        this.gameFrame = 0;
        this.staggerFrames = 5; 
        
        this.facingRight = true; 
        this.isMoving = false;

        this.addWeapon('magic_wand');
    }

    update() {
        let dx = 0;
        let dy = 0;

        if (keys['w'] || keys['ArrowUp']) dy = -1;
        if (keys['s'] || keys['ArrowDown']) dy = 1;
        if (keys['a'] || keys['ArrowLeft']) dx = -1;
        if (keys['d'] || keys['ArrowRight']) dx = 1;

        if (dx !== 0 || dy !== 0) {
            const length = Math.sqrt(dx*dx + dy*dy);
            dx /= length;
            dy /= length;
        }

        if (joystick.active) {
            dx = joystick.dx;
            dy = joystick.dy;
        }

        if (dx !== 0 || dy !== 0) {
            this.x += dx * GAME_CONFIG.playerSpeed * this.modifiers.moveSpeed;
            this.y += dy * GAME_CONFIG.playerSpeed * this.modifiers.moveSpeed;
            this.isMoving = true;
            if (dx > 0) this.facingRight = true;
            if (dx < 0) this.facingRight = false;
        } else {
            this.isMoving = false;
        }

        if (this.isMoving) {
            this.gameFrame++;
            if (this.gameFrame % this.staggerFrames === 0) {
                this.currentFrame = (this.currentFrame + 1) % this.totalFrames;
            }
        } else {
            this.currentFrame = 0; 
        }

        this.weapons.forEach(w => w.update(this));
    }

    draw() {
        const screenX = CANVAS.width / 2;
        const screenY = CANVAS.height / 2;
        
        if (playerSprite.complete && playerSprite.naturalWidth !== 0) {
            CTX.save(); 
            
            const displayH = 80;
            const displayW = displayH * (this.frameWidth / this.frameHeight);

            CTX.translate(screenX, screenY);

            if (this.facingRight) {
                CTX.scale(-1, 1);
            }

            CTX.drawImage(
                playerSprite,
                this.currentFrame * this.frameWidth, 
                0, 
                this.frameWidth, 
                this.frameHeight, 
                -displayW / 2, 
                -displayH / 2, 
                displayW, 
                displayH  
            );

            CTX.restore();
        } else {
            CTX.fillStyle = this.color;
            CTX.fillRect(screenX - this.width/2, screenY - this.height/2, this.width, this.height);
            CTX.strokeStyle = 'white';
            CTX.lineWidth = 2;
            CTX.strokeRect(screenX - this.width/2, screenY - this.height/2, this.width, this.height);
        }

        const barWidth = 40;
        const barHeight = 5;
        const barOffset = (playerSprite.complete && playerSprite.naturalWidth !== 0) ? 50 : 20;
        const barX = screenX - barWidth / 2;
        const barY = screenY - barOffset;

        CTX.fillStyle = '#e74c3c'; 
        CTX.fillRect(barX, barY, barWidth, barHeight);

        const hpPercent = Math.max(0, this.hp / this.maxHp);
        CTX.fillStyle = '#2ecc71';
        CTX.fillRect(barX, barY, barWidth * hpPercent, barHeight);
        
        CTX.strokeStyle = '#000';
        CTX.lineWidth = 1;
        CTX.strokeRect(barX, barY, barWidth, barHeight);
    }
    
    drawWeapons() {
        this.weapons.forEach(w => w.draw(this));
    }

    takeDamage(amount) {
        this.hp -= amount;
        updateHUD();
        if (this.hp <= 0) gameOver();
    }

    gainXp(amount) {
        this.xp += amount;
        if (this.xp >= this.xpToNextLevel) {
            this.levelUp();
        }
        updateHUD();
    }

    levelUp() {
        this.level++;
        this.xp -= this.xpToNextLevel;
        this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5);
        
        joystick.active = false;
        joystick.dx = 0;
        joystick.dy = 0;

        gameState.paused = true;
        showUpgradeMenu();
    }

    addWeapon(type) {
        const existing = this.weapons.find(w => w.type === type);
        if (existing) {
            existing.levelUp();
        } else {
            if (type === 'magic_wand') this.weapons.push(new MagicWand());
            if (type === 'garlic') this.weapons.push(new Garlic());
            if (type === 'axe') this.weapons.push(new Axe());
        }
    }
}

class Enemy {
    // T√ºm d√º≈üman tiplerini tutan statik dizi
    static types = [];

    /**
     * Yeni bir d√º≈üman tipi ekler
     * @param {Object} config - D√º≈üman ayarlarƒ±
     * @param {string} config.sprite - Resim yolu (√∂rn: 'monster.webp')
     * @param {number} config.spawnAtLevel - D√º≈ümanƒ±n spawn olmaya ba≈ülayacaƒüƒ± oyuncu seviyesi
     * @param {Object} config.stats - { hp: 20, speed: 1.5, damage: 10 } gibi
     * @param {Object} config.frameConfig - { width: 751, height: 169, frames: 8 } gibi (Sprite sheet detaylarƒ±)
     * @param {number} config.scale - G√∂rsel √ßizim boyutu (varsayƒ±lan 100px y√ºkseklik)
     * @param {string} config.fallbackColor - Resim yoksa g√∂r√ºnecek renk
     */
    static addNewType(config) {
        const img = new Image();
        img.src = config.sprite;
        
        Enemy.types.push({
            spriteImg: img,
            spawnAtLevel: config.spawnAtLevel || 1,
            stats: config.stats || { hp: 25, speed: 1.5, damage: 10 },
            frameConfig: config.frameConfig || { width: 64, height: 64, frames: 1 },
            scale: config.scale || 100,
            fallbackColor: config.fallbackColor || '#e74c3c'
        });
    }

    constructor() {
        // Doƒüacak yeri hesapla (ekran dƒ±≈üƒ±)
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.max(CANVAS.width, CANVAS.height) / 2 + 100;
        
        this.x = player.x + Math.cos(angle) * radius;
        this.y = player.y + Math.sin(angle) * radius;

        // --- Tƒ∞P SE√áƒ∞Mƒ∞ ---
        // Oyuncunun seviyesine uygun olanlarƒ± filtrele
        const eligibleTypes = Enemy.types.filter(t => player.level >= t.spawnAtLevel);
        
        // Eƒüer uygun tip yoksa (√∂rneƒüin level 1'de hi√ß tanƒ±m yoksa), listenin ilkini al, o da yoksa varsayƒ±lan yap
        let selectedType;
        if (eligibleTypes.length > 0) {
            selectedType = eligibleTypes[Math.floor(Math.random() * eligibleTypes.length)];
        } else if (Enemy.types.length > 0) {
             // Level yetmiyor ama tanƒ±mlƒ± d√º≈üman var, en d√º≈ü√ºƒü√ºn√º al
            selectedType = Enemy.types[0];
        } else {
            // Hi√ß d√º≈üman tanƒ±mlanmamƒ±≈üsa fallback
            selectedType = null; 
        }

        // Se√ßilen tipe g√∂re √∂zellikleri ata
        if (selectedType) {
            this.img = selectedType.spriteImg;
            this.frameConfig = selectedType.frameConfig;
            this.scale = selectedType.scale;
            this.color = selectedType.fallbackColor;

            // Statlarƒ± level √ßarpanƒ±yla biraz g√º√ßlendir
            this.hp = selectedType.stats.hp + (player.level * 2);
            this.speed = selectedType.stats.speed + (Math.random() * 0.2);
            this.damage = selectedType.stats.damage + (player.level * 0.2);
        } else {
            // Varsayƒ±lan (Eƒüer Enemy.addNewType hi√ß √ßaƒürƒ±lmazsa)
            this.img = null;
            this.frameConfig = { width: 0, height: 0, frames: 1 };
            this.scale = 40;
            this.color = '#ff0000';
            this.hp = 20;
            this.speed = 1.5;
            this.damage = 10;
        }

        this.width = 25; // Hitbox
        this.height = 25;

        // Sprite Animasyon deƒüi≈ükenleri
        this.totalFrames = this.frameConfig.frames;
        this.frameWidth = this.frameConfig.width / this.totalFrames;
        this.frameHeight = this.frameConfig.height;

        this.currentFrame = Math.floor(Math.random() * this.totalFrames);
        this.gameFrame = Math.floor(Math.random() * 10);
        this.staggerFrames = 8;
        this.facingRight = true;
    }

    update() {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist > 0) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
            
            if (dx > 0) this.facingRight = true;
            else this.facingRight = false;

            // Animasyon
            this.gameFrame++;
            if (this.gameFrame % this.staggerFrames === 0) {
                this.currentFrame = (this.currentFrame + 1) % this.totalFrames;
            }
        }

        if (dist < 30) {
            player.takeDamage(this.damage * 0.05);
        }
    }

    draw() {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;

        if (screenX < -50 || screenX > CANVAS.width + 50 || 
            screenY < -50 || screenY > CANVAS.height + 50) return;

        if (this.img && this.img.complete && this.img.naturalWidth !== 0) {
            CTX.save();

            const displayH = this.scale; 
            const displayW = displayH * (this.frameWidth / this.frameHeight);

            CTX.translate(screenX, screenY);

            if (this.facingRight) {
                CTX.scale(-1, 1);
            }

            CTX.drawImage(
                this.img,
                this.currentFrame * this.frameWidth,
                0,
                this.frameWidth,
                this.frameHeight,
                -displayW / 2,
                -displayH / 2,
                displayW,
                displayH
            );

            CTX.restore();
        } else {
            CTX.fillStyle = this.color;
            CTX.fillRect(screenX - this.width/2, screenY - this.height/2, this.width, this.height);
        }
    }
}

class Gem {
    constructor(x, y, value) {
        this.x = x;
        this.y = y;
        this.value = value;
        this.radius = 6;
        this.color = value > 10 ? '#34e7e4' : '#2ecc71';
    }

    update() {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < GAME_CONFIG.pickupRadius * 2) {
            this.x += (dx / dist) * 8;
            this.y += (dy / dist) * 8;
        }

        if (dist < 20) {
            player.gainXp(this.value);
            return true;
        }
        return false;
    }

    draw() {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        
        if (screenX < -20 || screenX > CANVAS.width + 20 || 
            screenY < -20 || screenY > CANVAS.height + 20) return;

        CTX.beginPath();
        CTX.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
        CTX.fillStyle = this.color;
        CTX.fill();
        CTX.strokeStyle = '#000';
        CTX.stroke();
    }
}

class DamageText {
    constructor(x, y, amount) {
        this.x = x;
        this.y = y;
        this.amount = Math.floor(amount);
        this.life = 30;
        this.vy = -2;
    }

    update() {
        this.y += this.vy;
        this.life--;
        return this.life <= 0;
    }

    draw() {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        
        CTX.fillStyle = `rgba(255, 255, 255, ${this.life / 30})`;
        CTX.font = 'bold 16px Arial';
        CTX.fillText(this.amount, screenX, screenY);
    }
}

/**
 * --- Sƒ∞LAH Sƒ∞STEMƒ∞ ---
 */

class Weapon {
    constructor(name, cooldown) {
        this.name = name;
        this.baseCooldown = cooldown;
        this.timer = 0;
        this.level = 1;
        this.damage = 10;
        this.type = '';
    }

    update(player) {
        if (this.timer > 0) {
            this.timer--;
        } else {
            this.fire(player);
            this.timer = this.baseCooldown / player.modifiers.speed;
        }
    }
    
    draw(player) { /* Override */ }

    levelUp() {
        this.level++;
        this.damage += 5;
        this.baseCooldown *= 0.9;
    }
    
    fire(player) { /* Override */ }
}

class MagicWand extends Weapon {
    constructor() {
        super('Asa', 60);
        this.type = 'magic_wand';
        this.damage = 15;
    }

    fire(player) {
        let closest = null;
        let minDist = Infinity;

        enemies.forEach(e => {
            const dx = e.x - player.x;
            const dy = e.y - player.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d < minDist) {
                minDist = d;
                closest = e;
            }
        });

        if (closest && minDist < 400) {
            projectiles.push(new Projectile(player.x, player.y, closest, this.damage));
        }
    }
}

class Garlic extends Weapon {
    constructor() {
        super('Sarƒ±msak', 10);
        this.type = 'garlic';
        this.radius = 80;
        this.damage = 2;
    }

    fire(player) {
        enemies.forEach(e => {
            const dx = e.x - player.x;
            const dy = e.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < (this.radius * player.modifiers.area)) {
                e.hp -= (this.damage * player.modifiers.power);
                e.x += (dx/dist) * 5;
                e.y += (dy/dist) * 5;
                
                if (gameState.frames % 10 === 0) {
                    texts.push(new DamageText(e.x, e.y, this.damage));
                }
                
                checkEnemyDeath(e);
            }
        });
    }

    draw(player) {
        const screenX = player.x - camera.x;
        const screenY = player.y - camera.y;

        CTX.beginPath();
        CTX.arc(screenX, screenY, this.radius * player.modifiers.area, 0, Math.PI*2);
        CTX.fillStyle = `rgba(255, 200, 200, ${0.1 + (Math.sin(gameState.frames * 0.1) * 0.05)})`;
        CTX.fill();
        CTX.strokeStyle = 'rgba(255, 100, 100, 0.3)';
        CTX.stroke();
    }
}

class Axe extends Weapon {
    constructor() {
        super('Balta', 90);
        this.type = 'axe';
        this.damage = 25;
    }
    
    fire(player) {
        let vx = (Math.random() - 0.5) * 4;
        let vy = -8;
        projectiles.push(new AxeProjectile(player.x, player.y, vx, vy, this.damage));
    }
}

class Projectile {
    constructor(x, y, target, damage) {
        this.x = x;
        this.y = y;
        this.damage = damage;
        this.speed = 7;
        this.radius = 5;
        this.markedForDeletion = false;

        const dx = target.x - x;
        const dy = target.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        this.vx = (dx / dist) * this.speed;
        this.vy = (dy / dist) * this.speed;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;

        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        if (screenX < -50 || screenX > CANVAS.width+50 || screenY < -50 || screenY > CANVAS.height+50) {
            this.markedForDeletion = true;
        }

        for (let e of enemies) {
            const dx = e.x - this.x;
            const dy = e.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < e.width) {
                e.hp -= this.damage;
                texts.push(new DamageText(e.x, e.y, this.damage));
                checkEnemyDeath(e);
                this.markedForDeletion = true;
                break;
            }
        }
    }

    draw() {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        CTX.fillStyle = '#f1c40f';
        CTX.beginPath();
        CTX.arc(screenX, screenY, this.radius, 0, Math.PI*2);
        CTX.fill();
    }
}

class AxeProjectile {
    constructor(x, y, vx, vy, damage) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.damage = damage;
        this.gravity = 0.3;
        this.markedForDeletion = false;
        this.width = 15;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;

        if (this.y > player.y + 400) this.markedForDeletion = true;

        for (let e of enemies) {
            const dx = e.x - this.x;
            const dy = e.y - this.y;
            if (Math.abs(dx) < 20 && Math.abs(dy) < 20) {
                e.hp -= this.damage;
                texts.push(new DamageText(e.x, e.y, this.damage));
                checkEnemyDeath(e);
            }
        }
    }

    draw() {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        CTX.fillStyle = '#95a5a6';
        CTX.fillRect(screenX, screenY, this.width, this.width);
    }
}

/**
 * --- OYUN D√ñNG√úS√ú DEƒûƒ∞≈ûKENLERƒ∞ ---
 */
let player;
let enemies = [];
let gems = [];
let projectiles = [];
let texts = [];
let keys = {};

window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

/**
 * --- D√ú≈ûMAN TANIMLAMALARI BURADA ---
 */

// 1. Tƒ∞P: Temel Ork (Level 1)
Enemy.addNewType({
    sprite: "orgWalkLeft.webp",
    spawnAtLevel: 1,
    stats: { hp: 25, speed: 1.5, damage: 10 },
    frameConfig: { width: 751, height: 169, frames: 8 },
    scale: 100,
    fallbackColor: '#e74c3c'
});

// 2. Tƒ∞P: √ñRNEK G√ú√áL√ú D√ú≈ûMAN (Level 3)
// NOT: Bu √∂rnek i√ßin aynƒ± resmi kullandƒ±m ama farklƒ± ayarlarla.
// Kendi "monster.webp" g√∂rselini buraya ekleyebilirsin.
Enemy.addNewType({
    sprite: "orgTwoWalk.webp", // Buraya "monster.webp" yazabilirsin
    spawnAtLevel: 2,
    stats: { hp: 80, speed: 1.2, damage: 25 }, // Daha canƒ± √ßok ama yava≈ü
    frameConfig: { width: 751, height: 169, frames: 8 },
    scale: 110, // Daha b√ºy√ºk g√∂r√ºn√ºr
    fallbackColor: '#8e44ad' // Resim yoksa Mor g√∂r√ºn√ºr
});
Enemy.addNewType({
    sprite: "orgThreeWalk.webp", 
    spawnAtLevel: 2,
    stats: { hp: 40*2, speed: 1.2, damage: 25 }, // Daha canƒ± √ßok ama yava≈ü
    frameConfig: { width: 751, height: 169, frames: 8 },
    scale: 100, // Daha b√ºy√ºk g√∂r√ºn√ºr
    fallbackColor: '#8e44ad' // Resim yoksa Mor g√∂r√ºn√ºr
});
Enemy.addNewType({
    sprite: "slymeWalk.webp", 
    spawnAtLevel: 3,
    stats: { hp: 40*3, speed: 1.2, damage: 30 }, // Daha canƒ± √ßok ama yava≈ü
    frameConfig: { width: 751, height: 169, frames: 8 },
    scale: 100, // Daha b√ºy√ºk g√∂r√ºn√ºr
    fallbackColor: '#8e44ad' // Resim yoksa Mor g√∂r√ºn√ºr
});
Enemy.addNewType({
    sprite: "zombieWalk.webp", 
    spawnAtLevel: 4,
    stats: { hp: 40*4, speed: 1, damage: 40 }, // Daha canƒ± √ßok ama yava≈ü
    frameConfig: { width: 751, height: 169, frames: 8 },
    scale: 80, // Daha b√ºy√ºk g√∂r√ºn√ºr
    fallbackColor: '#8e44ad' // Resim yoksa Mor g√∂r√ºn√ºr
});
Enemy.addNewType({
    sprite: "frankenstainWalk.webp", 
    spawnAtLevel: 5,
    stats: { hp: 40*8, speed: .6, damage: 50 }, // Daha canƒ± √ßok ama yava≈ü
    frameConfig: { width: 751, height: 169, frames: 8 },
    scale: 80*2, // Daha b√ºy√ºk g√∂r√ºn√ºr
    fallbackColor: '#8e44ad' // Resim yoksa Mor g√∂r√ºn√ºr
});

function initGame() {
    player = new Player();
    enemies = [];
    gems = [];
    projectiles = [];
    texts = [];
    gameState = {
        running: true,
        paused: false,
        frames: 0,
        time: 0,
        enemiesKilled: 0
    };
    updateHUD();
    gameLoop();
}

function spawnEnemy() {
    const spawnRate = Math.max(10, GAME_CONFIG.enemySpawnRate - Math.floor(gameState.time / 10));
    
    if (gameState.frames % spawnRate === 0) {
        if (enemies.length < GAME_CONFIG.maxEnemies) {
            enemies.push(new Enemy());
        }
    }
}

function checkEnemyDeath(enemy) {
    if (enemy.hp <= 0) {
        gems.push(new Gem(enemy.x, enemy.y, 10 + Math.random() * 5));
        gameState.enemiesKilled++;
    }
}

function update() {
    if (!gameState.running || gameState.paused) return;

    gameState.frames++;
    if (gameState.frames % 60 === 0) {
        gameState.time++;
        document.getElementById('timer').innerText = new Date(gameState.time * 1000).toISOString().substr(14, 5);
    }

    player.update();
    
    camera.x = player.x - CANVAS.width / 2;
    camera.y = player.y - CANVAS.height / 2;

    spawnEnemy();

    enemies = enemies.filter(e => e.hp > 0);
    enemies.forEach(e => e.update());

    projectiles.forEach(p => p.update());
    projectiles = projectiles.filter(p => !p.markedForDeletion);

    gems = gems.filter(g => !g.update());

    texts = texts.filter(t => !t.update());
}

function draw() {
    CTX.fillStyle = '#222';
    CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

    const gridSize = 100;
    const offsetX = -camera.x % gridSize;
    const offsetY = -camera.y % gridSize;
    
    CTX.strokeStyle = '#333';
    CTX.lineWidth = 1;
    CTX.beginPath();
    for (let x = offsetX; x < CANVAS.width; x += gridSize) {
        CTX.moveTo(x, 0);
        CTX.lineTo(x, CANVAS.height);
    }
    for (let y = offsetY; y < CANVAS.height; y += gridSize) {
        CTX.moveTo(0, y);
        CTX.lineTo(CANVAS.width, y);
    }
    CTX.stroke();

    gems.forEach(g => g.draw());
    
    if(player) player.drawWeapons();

    enemies.forEach(e => e.draw());
    projectiles.forEach(p => p.draw());
    
    if(player) player.draw();
    
    texts.forEach(t => t.draw());

    if (joystick.active) {
        CTX.beginPath();
        CTX.arc(joystick.originX, joystick.originY, joystick.maxRadius, 0, Math.PI * 2);
        CTX.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        CTX.lineWidth = 2;
        CTX.stroke();

        CTX.beginPath();
        CTX.arc(joystick.currentX, joystick.currentY, 20, 0, Math.PI * 2);
        CTX.fillStyle = 'rgba(255, 255, 255, 0.5)';
        CTX.fill();
    }
}

function gameLoop() {
    if (gameState.running) {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }
}

/**
 * --- UI FONKSƒ∞YONLARI ---
 */
function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    initGame();
}

function gameOver() {
    gameState.running = false;
    document.getElementById('gameover-screen').classList.remove('hidden');
    document.getElementById('final-stats').innerText = 
        `S√ºre: ${document.getElementById('timer').innerText} | √ñld√ºr√ºlen: ${gameState.enemiesKilled} | Seviye: ${player.level}`;
}

function updateHUD() {
    document.getElementById('kill-count').innerText = 'üíÄ ' + gameState.enemiesKilled;
    document.getElementById('level-display').innerText = 'LVL ' + player.level;
    document.getElementById('hp-display').innerText = `HP: ${Math.floor(player.hp)}/${player.maxHp}`;
    
    const xpPercent = (player.xp / player.xpToNextLevel) * 100;
    document.getElementById('xp-bar-fill').style.width = xpPercent + '%';
}

function showUpgradeMenu() {
    const container = document.getElementById('upgrade-options');
    container.innerHTML = '';
    
    const options = [
        { id: 'magic_wand', title: 'B√ºy√º Asasƒ±', desc: 'En yakƒ±n d√º≈ümana atƒ±≈ü yapar.' },
        { id: 'garlic', title: 'Sarƒ±msak', desc: 'Etrafƒ±nda hasar alanƒ± olu≈üturur.' },
        { id: 'axe', title: 'Balta', desc: 'Yukarƒ± doƒüru aƒüƒ±r hasarlƒ± balta atar.' },
        { id: 'heal', title: 'Tavuk Budu', desc: '%30 Can Yeniler.' },
        { id: 'speed', title: 'Hƒ±z ƒ∞ksiri', desc: 'Hareket hƒ±zƒ±nƒ± artƒ±rƒ±r.' }
    ];

    const choices = options.sort(() => 0.5 - Math.random()).slice(0, 3);

    choices.forEach(opt => {
        const div = document.createElement('div');
        div.className = 'upgrade-card';
        div.innerHTML = `<div class="upgrade-title">${opt.title}</div><div class="upgrade-desc">${opt.desc}</div>`;
        div.onclick = () => selectUpgrade(opt.id);
        container.appendChild(div);
    });

    document.getElementById('levelup-screen').classList.remove('hidden');
}

function selectUpgrade(id) {
    if (id === 'heal') {
        player.hp = Math.min(player.hp + 30, player.maxHp);
    } else if (id === 'speed') {
        player.modifiers.moveSpeed += 0.1;
    } else {
        player.addWeapon(id);
    }
    
    document.getElementById('levelup-screen').classList.add('hidden');
    gameState.paused = false;
    joystick.active = false; 
    updateHUD();
}

window.addEventListener('resize', () => {
    CANVAS.width = window.innerWidth;
    CANVAS.height = window.innerHeight;
});

</script>
</body>
</html>